<!DOCTYPE html>
<html>
<head>
  <script src="/TFB_leaderboard.github.io/js/jquery.min.js"></script>
  <link rel="icon" type="image/png" href="/TFB_leaderboard.github.io/figures/logo10.png">
  <meta charset="utf-8">
  
  <title>TFB-leaderboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="LeaderboardsTable of Contents    Univariate time series Multivariate time series Methods introduction Rules  Leaderboard for univariate time series forecasting   &#x2F;* 基本表格样式 *&#x2F; table.my-table1 {   width">
<meta property="og:type" content="website">
<meta property="og:title" content="TFB-leaderboard">
<meta property="og:url" content="https://decisionintelligence.github.io/TFB_leaderboard.github.io/leaderboards/index.html">
<meta property="og:site_name" content="TFB-leaderboard">
<meta property="og:description" content="LeaderboardsTable of Contents    Univariate time series Multivariate time series Methods introduction Rules  Leaderboard for univariate time series forecasting   &#x2F;* 基本表格样式 *&#x2F; table.my-table1 {   width">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-07-05T16:48:39.653Z">
<meta property="article:modified_time" content="2024-07-05T16:48:39.653Z">
<meta property="article:author" content="DecisionIntelligence |">
<meta name="twitter:card" content="summary">
  

  <link href="/TFB_leaderboard.github.io/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/TFB_leaderboard.github.io/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/TFB_leaderboard.github.io/css/style.css">

  

<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <!-- blair add baidu tongji start... @2017.10.03 -->
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?8864d";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>
<!-- blair add baidu tongji end ! @2017.10.03 -->
<!-- jiangting add start... @2020.08.30 -->

<!-- jiangting add end !  @2020.08.30 -->

<header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <!-- <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a> -->
      <a id="logo" style="margin:3px 0" class="logo" href="/TFB_leaderboard.github.io/"></a>
      <nav id="main-nav">
        
          
            <a class="main-nav-link" href="/TFB_leaderboard.github.io/">Overview</a>
          
        
          
            <div class="dropdown">
              <a class="main-nav-link dropdown-toggle" href="/TFB_leaderboard.github.io/get%20started">Get Started <span class="caret"></span></a>
              <div class="dropdown-content">
                
                  <a href="/TFB_leaderboard.github.io/get%20started/#Quickstart">Quickstart</a>
                
                  <a href="/TFB_leaderboard.github.io/get%20started/#Steps-to-develop-your-own-method">Steps to develop your own method</a>
                
                  <a href="/TFB_leaderboard.github.io/get%20started/#FAQ">FAQ</a>
                
                  <a href="/TFB_leaderboard.github.io/get%20started/#Citing-TFB">Citing TFB</a>
                
                  <a href="/TFB_leaderboard.github.io/get%20started/#Contact">Contact</a>
                
              </div>
            </div>
          
        
          
            <div class="dropdown">
              <a class="main-nav-link dropdown-toggle" href="/TFB_leaderboard.github.io/datasets">Datasets <span class="caret"></span></a>
              <div class="dropdown-content">
                
                  <a href="/TFB_leaderboard.github.io/datasets/#Overview">Overview</a>
                
                  <a href="/TFB_leaderboard.github.io/datasets/#Univariate-time-series">Univariate time series</a>
                
                  <a href="/TFB_leaderboard.github.io/datasets/#Multivariate-time-series">Multivariate time series</a>
                
              </div>
            </div>
          
        
          
            <div class="dropdown">
              <a class="main-nav-link dropdown-toggle" href="/TFB_leaderboard.github.io/leaderboards">Leaderboards <span class="caret"></span></a>
              <div class="dropdown-content">
                
                  <a href="/TFB_leaderboard.github.io/leaderboards/#Leaderboard-for-univariate-time-series-forecasting">Univariate time series</a>
                
                  <a href="/TFB_leaderboard.github.io/leaderboards/#Leaderboard-for-multivariate-time-series-forecasting">Multivariate time series</a>
                
                  <a href="/TFB_leaderboard.github.io/leaderboards/#Methods-introduction">Methods introduction</a>
                
                  <a href="/TFB_leaderboard.github.io/leaderboards/#Rules">Rules</a>
                
              </div>
            </div>
          
        
          
            <a class="main-nav-link" href="/TFB_leaderboard.github.io/paper">Paper</a>
          
        
          
            <a class="main-nav-link" target="_blank" rel="noopener" href="https://github.com/decisionintelligence/TFB">Github</a>
          
        
      </nav>
    </div>
  </div>
</header>

<style>
  #header {
    position: relative;
    z-index: 10;
    overflow: visible;
  }

  #header-outer {
    position: relative;
    z-index: 10;
    overflow: visible;
  }

  #header-inner {
    position: relative;
    z-index: 10;
    overflow: visible;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 10px;
    max-width: 870px; /* 设置最大宽度 */
    margin: auto; /* 居中对齐 */
    width: 100%; /* 确保占满父元素的宽度 */
    flex-wrap: nowrap; /* 保持内容在同一行 */
  }

  .dropdown {
    position: relative;
    display: inline-block;
    text-align: right;
  }

  .dropdown-content {
    display: none;
    position: absolute;
    background-color: #f9f9f9;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    z-index: 1000;
    top: 100%;
    right: 0;
    width: auto;
    min-width: 100%;
    white-space: nowrap;
  }

  .dropdown-content a {
    color: black;
    padding: 12px 16px;
    text-decoration: none;
    display: block;
    text-align: left;
    border-top: 1px solid #ddd;
  }

  .dropdown-content a:first-child {
    border-top: none;
  }

  .dropdown-content a:hover {
    background-color: #f1f1f1;
  }

  .dropdown:hover .dropdown-content {
    display: block;
  }

  .dropdown-toggle::after {
    content: " ▼";
    font-size: 0.55em;
    vertical-align: middle;
  }

  #main-nav {
    display: flex;
    align-items: center;
    flex-grow: 1;
    justify-content: space-around;
    flex-wrap: nowrap; /* 保持内容在同一行 */
  }

  .main-nav-link {
    padding: 0 10px; /* 减少 padding，缩小栏目间距 */
  }

  

  @media (max-width: 480px) {
    .main-nav-link {
      padding: 5px; /* 进一步减少 padding，在小屏幕上更紧凑 */
      flex: 1;
      text-align: center;
    }
  }
</style>

    <br>
    <section id="main" class="outer"><article id="page-" class="article article-type-page" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    <div class="article-meta">
      <!--<a href="/TFB_leaderboard.github.io/leaderboards/index.html" class="article-date">
  <time datetime="2024-07-05T16:48:39.653Z" itemprop="datePublished">2024-07-06</time>
</a>-->
      <!-- 
--><!-- by blair 160724 -->
      <!-- by blair
      
      -->
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Leaderboards"><a href="#Leaderboards" class="headerlink" title="Leaderboards"></a>Leaderboards</h1><p><strong>Table of Contents</strong></p>
<!-- 1. [Overview](#Overview) -->

<ol>
<li><a href="#Leaderboard-for-univariate-time-series-forecasting">Univariate time series</a></li>
<li><a href="#Leaderboard-for-multivariate-time-series-forecasting">Multivariate time series</a></li>
<li><a href="#Methods-introduction">Methods introduction</a></li>
<li><a href="#Rules">Rules</a></li>
</ol>
<h2 id="Leaderboard-for-univariate-time-series-forecasting"><a href="#Leaderboard-for-univariate-time-series-forecasting" class="headerlink" title="Leaderboard for univariate time series forecasting"></a>Leaderboard for univariate time series forecasting</h2><style>
  /* 基本表格样式 */
table.my-table1 {
  width: 100%;
  border-collapse: collapse;
  font-family: Arial, sans-serif;
  border: none; /* 去除表格边框 */
}
/* 表头样式 */
table.my-table1 th {
  background-color: #f2f2f2; /* 表头背景色（奇数行浅灰色） */
  color: black; /* 表头文字颜色 */
  font-weight: bold; /* 表头字体加粗 */
  padding: 10px; /* 调整表头内边距 */
  text-align: center; /* 居中对齐 */
  border: none;
}

/* 偶数行背景色 */
table.my-table1 tr:nth-child(odd) {
  background-color: #ffffff; /* 偶数行背景色（白色） */
}

/* 奇数行背景色 */
table.my-table1 tr:nth-child(even) {
  background-color: #f2f2f2; /* 奇数行背景色（浅灰色） */
}

/* 单元格样式 */
table.my-table1 td {
  padding: 8px; /* 调整单元格内边距 */
  text-align: center; /* 居中对齐 */
  border: none; /* 去除单元格边框 */
  white-space: nowrap; /* 防止文本换行 */
  /* overflow: hidden; 隐藏溢出内容
  text-overflow: ellipsis; 溢出内容显示省略号
  max-width: 200px; 设置单元格最大宽度 */
}

/* 第4行单独样式 */
table.my-table1 tr td:nth-child(1),table.my-table1 tr th:nth-child(1)  {
    /* text-align: left; */
  /* max-width: 150px; 设置第4行单元格最大宽度 */
}
/* 第4行单独样式 */
table.my-table1 tr td:nth-child(2)  {
  /* max-width: 80px; 设置第4行单元格最大宽度 */
}
/* 第4行单独样式 */
table.my-table1 tr td:nth-child(7)  {
  /* max-width: 100px; 设置第4行单元格最大宽度 */
}

</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

<div style="width:95%" class="table-container">
<table id="univariateTable" class="my-table2">
    <thead>
        <tr>
            <th>Rank</th>
            <th>Method</th>
            <th>
            <select onchange="handleSelectChange(event)">
            <option value="MSMAPE">MSMAPE</option>
            <option value="RANK">#Top1</option>
            </select>
            </th>
            <th>Contact</th>
            <th>Paper</th>
            <th>Code</th>
            <th>Publication</th>
            <th>Year</th>
        </tr>
    </thead>
    <tbody>
    </tbody>
</table>
</div>
<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">Table 1: Univariate forecasting results.</center>

<script>
    function handleSelectChange(event)
    {

        if (event.target.value == 'MSMAPE')
        {
            // console.log('MSMAPE')
            msmape()
        }
        else
        {   
            // console.log('rank')
            data_rank()
        }
    }
    function msmape()
    {
        const csvFilePath1 = 'univariate_msmape.csv'; 
        fetch(csvFilePath1)
            .then(response => response.text())
            .then(text => Papa.parse(text, {
                header: true,
                dynamicTyping: true,
                complete: function(results) {
                    const data = results.data;
                    processData(data);
                }
            }));
    }
    

    function processData(data) {
        // Extract metadata
        const contactText = data[0];
        const contactUrl = data[1];
        const paperUrl = data[2];
        const codeUrl = data[3];
        const pub = data[4]
        const bib = data[5]
        const year = data[6]
    
        // Filter out metadata rows
        const dataRows = data.slice(7);
    
        // Calculate the weighted average for each method
        const numsIndex = dataRows[0].nums;
        const methods = Object.keys(dataRows[0]).filter(key => key !== 'nums' && key !== 'Dataset');
    
        const weightedAverages = methods.map(method => {
            let weightedSum = 0;
            let totalNums = 0;
            dataRows.forEach(row => {
                const nums = parseFloat(row.nums);
                const value = parseFloat(row[method]);
                if (!isNaN(nums) && !isNaN(value)) {
                    weightedSum += nums * value;
                    totalNums += nums;
                }univariateTable
            });
            const weightedAverage = weightedSum / totalNums;
            return {
                method: method,
                weightedAverage: weightedAverage,
                contact: contactText[method],
                contactUrl: contactUrl[method],
                paperUrl: paperUrl[method],
                codeUrl: codeUrl[method],
                pub:pub[method],
                bib:bib[method],
                year:year[method]
                // bib:bib[methd],
            };
        });
    
        weightedAverages.sort((a, b) => a.weightedAverage - b.weightedAverage);
    
        const tableBody = document.querySelector('#univariateTable tbody');
        
        tableBody.innerHTML = weightedAverages.map((entry, rank) => 
        {   if(rank==0)
            {
                rank='🥇'
            }else if(rank ==1)
            {
                rank = '🥈'
            }else if(rank ==2)
            {
                rank = '🥉'
            }else
            {
                rank = rank+1
            }
            return `<tr>
                <td>${rank}</td>
                <td>${entry.method}</td>
                <td>${entry.weightedAverage.toFixed(2)}</td>
                <td><a href="mailto:${entry.contactUrl}" target="_blank">${entry.contact}</a></td>
                <td><a href="${entry.paperUrl}" target="_blank">paper</a></td>
                <td><a href="${entry.codeUrl}" target="_blank">code</a>
                <td> ${entry.pub} [<a href="${entry.bib}" target="_blank">bib</a>]</td>
                <td >${entry.year}</td>
    
            </tr>
        `}).join('');
    }
    msmape()
</script>

<script>
    function data_rank()
    {
        const csvFilePath2 = 'univariate_rank.csv'; 
        fetch(csvFilePath2)
            .then(response => response.text())
            .then(text => Papa.parse(text, {
                header: true,
                dynamicTyping: true,
                complete: function(results) {
                    const data = results.data;
                    processData1(data);
                }
            }));
    }
    
    function processData1(data) {
        // Extract metadata
        const contactText = data[0];
        const contactUrl = data[1];
        const paperUrl = data[2];
        const codeUrl = data[3];
        const pub = data[4]
        const bib = data[5]
        const year = data[6]
        
        // Filter out metadata rows
        const dataRows = data.slice(7);
    
        // Calculate the weighted average for each method
        const numsIndex = dataRows[0].nums;
        const methods = Object.keys(dataRows[0]).filter(key => key !== 'nums' && key !== 'dataset');
    
        const weightedAverages = methods.map(method => {
            
            let weightedSum = 0;
    
            dataRows.forEach(row => {
                const nums = parseFloat(row.nums);
                const value = parseFloat(row[method]);
                if (!isNaN(value)) {
                    // console.log(method,weightedSum)
                    weightedSum +=  value;
      
                }
            });
            
            const weightedAverage = weightedSum / 5;
            return {
                method: method,
                weightedAverage: weightedAverage,
                contact: contactText[method],
                contactUrl: contactUrl[method],
                paperUrl: paperUrl[method],
                codeUrl: codeUrl[method],
                pub:pub[method],
                bib:bib[method],
                year:year[method]
                // bib:bib[methd],
            };
        });
    
        weightedAverages.sort((a, b) => b.weightedAverage - a.weightedAverage);
        
        const tableBody = document.querySelector('#univariateTable tbody');
        
        tableBody.innerHTML = weightedAverages.map((entry, rank) => {
            if(rank==0)
            {
                rank='🥇'
            }else if(rank ==1)
            {
                rank = '🥈'
            }else if(rank ==2)
            {
                rank = '🥉'
            }else
            {
                rank = rank+1
            }
            return `<tr>
                <td>${rank}</td>
                <td>${entry.method}</td>
                <td>${entry.weightedAverage.toFixed(0)}</td>
                <td><a href="mailto:${entry.contactUrl}" target="_blank">${entry.contact}</a></td>
                <td><a href="${entry.paperUrl}" target="_blank">paper</a></td>
                <td><a href="${entry.codeUrl}" target="_blank">code</a>
                
                 <td> ${entry.pub} [<a href="${entry.bib}" target="_blank">bib</a>]</td>
                 
                <td >${entry.year}</td>
    
            </tr>
        `}).join('');
    }
</script>

<h2 id="Leaderboard-for-multivariate-time-series-forecasting"><a href="#Leaderboard-for-multivariate-time-series-forecasting" class="headerlink" title="Leaderboard for multivariate time series forecasting"></a>Leaderboard for multivariate time series forecasting</h2><script>
function displayResults(rankCounts, connectTexts, connectUrls, paperUrls, codeUrls,pub,bib,year,table,is_rank) {

    const tableBody = document.getElementById(table).getElementsByTagName('tbody')[0];
    tableBody.innerHTML = ''; // Clear existing table body
    
    rankCounts.sort((a, b) => b['rank4'] - a['rank4'] );


    rankCounts.forEach(( counts, index) => {
        model = counts['model']
        
        if(index==0)
        {
            index='🥇'
        }else if(index ==1)
        {
            index = '🥈'
        }else if(index ==2)
        {
            index = '🥉'
        }else
        {
            index = index+1
        }
        if (!is_rank)
        {
            index=''
        }
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${index}</td>
            <td>${model}</td>
            <td>${counts['rank4']}</td>
            <td>${counts['rank1']}</td>
            <td>${counts['rank2']}</td>
            <td>${counts['rank3']}</td>
            
            <td><a href="mailto:${connectUrls[model]}" target="_blank">${connectTexts[model]}</a></td>
            <td>
                <a href="${paperUrls[model]}"  target="_blank">paper</a>
            </td>
            <td>
                <a href="${codeUrls[model]}" target="_blank">code</a>
            </td>
            
            <td>
             ${pub[model]} [<a href="${bib[model]}" target="_blank">bib</a>]
        
            </td>
            <td >
                ${year[model]}
            </td>
        `;
        tableBody.appendChild(row);
    });
}

function phraseMultiTable(results, table, datasets) {
     // Prepare results
    const result = [];
    const data = results.data;

    // Extract new fields
    const connectTexts = {}, connectUrls = {}, paperUrls = {}, codeUrls = {}, pub = {}, year = {}, bib = {};

    // Extract metadata from the first seven rows
    for (let i = 0; i < 7; i++) {
        const row = data[i];
        for (const key in row) {
            if (key !== 'Dataset-Quantity-metrics') {
                if (i === 0) connectTexts[key] = row[key];
                if (i === 1) connectUrls[key] = row[key];
                if (i === 2) paperUrls[key] = row[key];
                if (i === 3) codeUrls[key] = row[key];
                if (i === 4) pub[key] = row[key];
                if (i === 5) bib[key] = row[key];
                if (i === 6) year[key] = row[key];
            }
        }
    }
    const all_datasets = new Set();

    // Loop through all rows in the data
    for (let i = 7; i < data.length; i++) {
        const row = data[i];
        
        // Check if 'Dataset-Quantity-metrics' exists and is not null
        if (row['Dataset-Quantity-metrics']) {
            all_datasets.add(row['Dataset-Quantity-metrics'].split('-')[0]);
        }
    }

    // Remove the first seven rows (metadata)
    const experimentData = data.slice(7);

    // Filter experiment data based on provided dataset list
      const filteredExperimentData = experimentData.filter(row => {
        if (row && row['Dataset-Quantity-metrics']) {
            const dataset = row['Dataset-Quantity-metrics'];
            return dataset && datasets.includes(dataset.split('-')[0]);
        }
        return false;
    });


    if (filteredExperimentData.length == 0 || datasets.length ==0)
    {
        const tableBody = document.getElementById('multivariateTable2').getElementsByTagName('tbody')[0];
       
        const modelColumns = Object.keys(experimentData[0]).slice(1);
        const rankCounts = {};
        modelColumns.forEach(model => {
            rankCounts[model] = {1: 0, 2: 0, 3: 0, 4: 0};
        });
         Object.entries(rankCounts).forEach(([model, values]) => {
        result.push({"model": model, 'rank1': values['1'], 'rank2': values['2'], 'rank3': values['3'], 'rank4': values['4']});
    });

        displayResults(result, connectTexts, connectUrls, paperUrls, codeUrls, pub, bib, year, table,false);
        return all_datasets;
    }
    // Identify model columns
    const modelColumns = Object.keys(filteredExperimentData[0]).slice(1);
    const rankCounts = {};
    modelColumns.forEach(model => {
        rankCounts[model] = {1: 0, 2: 0, 3: 0, 4: 0};
    });

    // Process filtered experiment data
    filteredExperimentData.forEach(row => {
        const validModels = modelColumns.filter(model => !isNaN(row[model]));
        validModels.sort((a, b) => row[a] - row[b]);
        validModels.slice(0, 4).forEach((model, index) => {
            rankCounts[model][index + 1]++;
        });
        validModels.forEach(model => {
            rankCounts[model][4] = 3 * rankCounts[model][1] + 2 * rankCounts[model][2] + rankCounts[model][3];
        });
    });

   
    Object.entries(rankCounts).forEach(([model, values]) => {
        result.push({"model": model, 'rank1': values['1'], 'rank2': values['2'], 'rank3': values['3'], 'rank4': values['4']});
    });

    // Display results
    displayResults(result, connectTexts, connectUrls, paperUrls, codeUrls, pub, bib, year, table,true);
    return all_datasets;
}

function populateCheckboxes(datasets) {
        const container = document.getElementById('dataset-container');
        datasets.forEach(dataset => {
            const div = document.createElement('div');
            div.className = 'checkbox-item';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = dataset;
            checkbox.value = dataset;
            checkbox.addEventListener('change', submitSelection);
            const label = document.createElement('label');
            label.htmlFor = dataset;
            label.textContent = dataset;
            div.appendChild(checkbox);
            div.appendChild(label);
            container.appendChild(div);
        });
    }
function submitSelection() {
            const selectedDatasets = [];
            const checkboxes = document.querySelectorAll('#dataset-container input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selectedDatasets.push(checkbox.value);
                }
            });
            // console.log('Selected Datasets:', selectedDatasets);
            fetch('multivariate_total.csv')
            .then(response => response.text())
            .then(text => Papa.parse(text, {
            header: true,
            dynamicTyping: true,
            complete:function(results){
            phraseMultiTable(results,'multivariateTable2',selectedDatasets)
        } 
    }));
            // Perform any further actions with the selected datasets
        }

        function toggleSelectAll(selectAllCheckbox) {
            const checkboxes = document.querySelectorAll('#dataset-container input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
            });
            submitSelection()
        }

fetch('multivariate_total.csv')
    .then(response => response.text())
    .then(text => Papa.parse(text, {
        header: true,
        dynamicTyping: true,
        complete:function(results){
            populateCheckboxes(phraseMultiTable(results,'multivariateTable2',["Traffic","Solar","ILI","Electricity","Weather","Exchange","ETTm2","ETTm1","ETTh2","ETTh1","AQShunyi","AQWan","NN5","Wike2000","Wind","ZafNoo","CzeLan","Covid19","NASDAQ","NYSE","FRED","PEMS04","PEMS","METR","PEMS08"]))
            const selectAllCheckbox = document.getElementById('select-all');
            // if (selectAllCheckbox) {
            //     selectAllCheckbox.checked = true;
            //     toggleSelectAll(selectAllCheckbox); // Ensure all individual checkboxes are also checked
            // }
            // submitSelection()
            // setContainerHeight()
        } 
    }));

function setContainerHeight() {
    const tableContainer = document.querySelector('.table-container');
    const mainContainer = document.querySelector('.main-container');
    mainContainer.style.height = tableContainer.offsetHeight + 'px';
}

</script>
<style>
/* 基本表格样式 */
table.my-table2 {
  width: 100%;
  border-collapse: collapse;
  font-family: Arial, sans-serif;
  border: none; /* 去除表格边框 */
  padding:0;
  margin:0
}

/* 表头样式 */
table.my-table2 th {
  background-color: #f2f2f2; /* 表头背景色（奇数行浅灰色） */
  color: black; /* 表头文字颜色 */
  font-weight: bold; /* 表头字体加粗 */
  padding: 10px; /* 调整表头内边距 */
  text-align: center; /* 居中对齐 */
   white-space: nowrap; /* 防止文本换行 */
  border: none;
}

/* 偶数行背景色 */
table.my-table2 tr:nth-child(odd) {
  background-color: #ffffff; /* 偶数行背景色（白色） */
}

/* 奇数行背景色 */
table.my-table2 tr:nth-child(even) {
  background-color: #f2f2f2; /* 奇数行背景色（浅灰色） */
}

/* 单元格样式 */
table.my-table2 td {
  padding: 8px; /* 调整单元格内边距 */
  text-align: center; /* 居中对齐 */
  border: none; /* 去除单元格边框 */
  white-space: nowrap; /* 防止文本换行 */
  /* overflow: hidden; 隐藏溢出内容
  text-overflow: ellipsis; 溢出内容显示省略号 */
  /* max-width: 200px; 设置单元格最大宽度
  position: relative; 设置相对定位以显示悬停内容 */
}

/* 第4列单独样式 */
table.my-table2 tr td:nth-child(4) {
  /* max-width: 150px; 设置第4列单元格最大宽度 */
}

/* 第2列单独样式 */
table.my-table2 tr td:nth-child(2) {
  /* max-width: 80px; 设置第2列单元格最大宽度 */
}

/* 第7列单独样式 */
table.my-table2 tr td:nth-child(7) {
  /* max-width: 100px; 设置第7列单元格最大宽度 */
}
.table-container {
  width: 100%; /* Adjust width as needed */
  max-width: 100%; /* Ensure it doesn't exceed the container width */
  /* Adjust height as needed */
  overflow-x: auto; /* Enable horizontal scroll */
  overflow-y: hidden; /* Enable vertical scroll */
  padding-left: 0px;
}
.table-container {
  width: 80%; /* Adjust width as needed */
  /* max-width: 100%; Ensure it doesn't exceed the container width */
  /* Adjust height as needed */
  overflow-x: auto; /* Enable horizontal scroll */
  margin:auto;
  overflow-y: hidden; /* Enable vertical scroll */
  display: flex;justify-content: LEFT;
}
 select {
    background-color: #f2f2f2; /* 表头背景色（奇数行浅灰色） */
    color: black; /* 表头文字颜色 */
    font-weight: bold; /* 表头字体加粗 */
    text-align: center; /* 居中对齐 */
    white-space: nowrap; /* 防止文本换行 */
    border: none;
    margin:auto;
    }
select:focus {
  border: none; /* 确保选中时没有边框 */
  outline: none; /* 确保选中时没有黑框 */
}
option
{
    padding:5px,0;
}

</style>

<style>
.main-container {
    display: flex;
    align-items: stretch; /* Stretch items to the same height */
    height: 100%;
}

.checkbox-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding-right: 20px; /* Add some space between checkboxes and table */
    overflow-y: auto; /* Enable vertical scroll if needed */
}
.checkbox-wrapper {
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    height: 100%;
}

</style>

<div class="main-container">
    <!-- <div class="checkbox-wrapper" style="display:none">
        <input type="checkbox" id="select-all" onclick="toggleSelectAll(this)">
        <label for="select-all">All</label>
        <div class="checkbox-container" id="dataset-container">
        </div>
    </div> -->
    <div style="width:95%" class="table-container">
        <table id="multivariateTable2" class="my-table2">
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Model</th>
                    <th>Score</th>
                    <th>#Top1</th>
                    <th>#Top2</th>
                    <th>#Top3</th>
                    <th>Contact</th>
                    <th>Paper</th>
                    <th>Code</th>
                    <th>Publication</th>
                    <th>Year</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>
</div>

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">Table 2: Multivariate forecasting results.</center>

<h2 id="Methods-introduction"><a href="#Methods-introduction" class="headerlink" title="Methods introduction"></a>Methods introduction</h2><p>TFB evaluated a diverse range of methods, including statistical learning, machine learning, and deep learning methods.</p>
<p><strong>Statistical Learning (SL)</strong>: ARIMA, ETS, Kalman Filter, and VAR</p>
<p><strong>Mtatistical Learning (ML):</strong> XGBModel , LinearRegression, and Random Forest</p>
<p><strong>Deep Learning (DL):</strong> </p>
<ul>
<li>RNN-based models (RNN)</li>
<li>CNN-based models (MICN, TimesNet, and TCN)</li>
<li>MLP-based models (NLinear, DLinear, TiDE, N-HiTS, and N-BEATS)</li>
<li>Transformer-based models (PatchTST, Crossformer, and FEDformer, Non-stationary Transformer, Informer, and Triformer)</li>
<li>Model-Agnostic models (FiLM)</li>
</ul>
<h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2><p>Public leaderboards allow researchers to keep track of state-of-the-art methods and encourage reproducible research.</p>
<ul>
<li>For univariate forecasting algorithms, we provide two optional rankings for each algorithm. The first ranking is to calculate the average value of the MSMAPE metric over 8068 time series, with the smaller the average value, the better the ranking. The second ranking is to calculate the number of times it achieves the best performance on the MSMAPE metric across 8068 time series, with the more times the better the ranking.</li>
<li>For multivariate forecasting algorithms, we calculate the number of times each algorithm achieves the best performance on 25 datasets, with 4 forecasting horizon for each dataset and two error metrics <strong>(25 * 4 * 2 &#x3D; 200)</strong>, and count them as <strong>x</strong>. The number of times the second best performance is achieved is counted as <strong>y</strong>. The number of times the third best performance is achieved is counted as <strong>z</strong>. Then calculate the final score as: <strong>score &#x3D; 3 * x + 2 * y + 1 * z</strong>. The larger the final score, the better the ranking.</li>
</ul>

      
    
    </div>
    
    
      <footer class="article-footer">
        <!-- <div class="well" style="width:100px; height:30px;"></div>  by blair-->
        
 <!-- by blair add 160724-->
        <!--
        <div style="width:100px; height:30px;"></div> by blair add 160724
        -->
        

      </footer>
    
  </div>
  
    
  
</article>

</section>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 DecisionIntelligence |&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a target="_blank" rel="noopener" href="http://github.com/52binge/hexo-theme-blairos">blairos</a>
    </div>
  </div>
</footer> -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX"],
    tex2jax: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      displayMath: [ ['$$','$$']],
      processEscapes: true
    }
  });
</script>
<script type="text/javascript" >
</script>

    






<script src="/TFB_leaderboard.github.io/js/script.js"></script>


  </div>
</body>
</html>
